<main class="page">
  <section class="hero">
    <div class="hero-copy">
      <p class="eyebrow">In-browser audio extraction</p>
      <h1>{{ title }}</h1>
      <p class="lead">
        Drop any video or audio file and get a clean MP3 without uploading it anywhere. Mediabunny runs the
        entire conversion locally so your media and metadata never leave this tab.
      </p>
      <ul class="benefits">
        <li>Works with MP4, MOV, MKV, WebM, WAV, OGG, FLAC, MP3, and ADTS containers.</li>
        <li>Automatic MP3 encoder loads on demand if your browser needs it.</li>
        <li>Progressive logs keep you informed at every stage of the pipeline.</li>
      </ul>
    </div>

    <div class="hero-card">
      <article class="converter-card">
        <header>
          <h2>Convert a file</h2>
          <p>Choose a recording, we’ll handle the mp3 extraction locally.</p>
        </header>

        <label
          class="file-drop"
          [class.dragging]="isDragOver()"
          (dragover)="onDragOver($event)"
          (dragleave)="onDragLeave($event)"
          (drop)="onDrop($event)"
        >
          <input id="fileInput" type="file" accept="video/*,audio/*" (change)="onFileSelected($event)" />
          <div class="drop-inner">
            <span class="icon">⬆</span>
            <p><strong>Select a video</strong> or drag &amp; drop it here</p>
            <small>Supported up to a few GB. Larger files take longer to load into memory.</small>
          </div>
        </label>

        <div class="file-meta" *ngIf="selectedFile() as file">
          <div>
            <span class="name">{{ file.name }}</span>
            <span class="size">{{ formatBytes(file.size) }}</span>
          </div>
          <button class="link" type="button" (click)="clearSelection()" [disabled]="isConverting()">Clear</button>
        </div>

        <div class="actions">
          <button type="button" (click)="convertSelected()" [disabled]="!selectedFile() || isConverting()">
            {{ isConverting() ? 'Converting…' : 'Extract Audio' }}
          </button>
          <button type="button" class="ghost" (click)="cancelConversion()" *ngIf="isConverting()">Cancel</button>
        </div>

        <div class="status-block" [class.has-error]="errorMessage()" [class.success]="downloadUrl()">
          <p>{{ status() }}</p>
          <p class="error" *ngIf="errorMessage()">{{ errorMessage() }}</p>
        </div>

        <div class="progress-area" *ngIf="isConverting() || progress() > 0">
          <div class="progress-header">
            <span>Progress</span>
            <span>{{ progress() }}%</span>
          </div>
          <progress [value]="progress()" max="100"></progress>
        </div>

        <div class="download" *ngIf="downloadUrl()">
          <a class="download-link" [href]="downloadUrl()" [download]="(outputFileName() ?? 'audio.mp3')">
            Download {{ outputFileName() || 'audio.mp3' }}
          </a>
        </div>

        <details class="log-view" *ngIf="logs().length">
          <summary>Conversion log</summary>
          <pre>{{ logs().join('\n') }}</pre>
        </details>
      </article>
    </div>
  </section>

  <section class="steps" aria-label="How it works">
    <h2>Three simple steps</h2>
    <ol>
      <li>
        <span class="step">1</span>
        <h3>Pick a media file</h3>
        <p>Grab footage from meetings, screen recordings, lectures, podcasts, or livestreams.</p>
      </li>
      <li>
        <span class="step">2</span>
        <h3>Process in your browser</h3>
        <p>Mediabunny uses WebCodecs + LAME to transcode without hitting any server.</p>
      </li>
      <li>
        <span class="step">3</span>
        <h3>Download the MP3</h3>
        <p>Save or share the extracted audio instantly—no queue, no rate limits.</p>
      </li>
    </ol>
  </section>

  <section class="feature-grid" aria-label="Why it’s different">
    <article>
      <h3>Private by design</h3>
      <p>Everything runs on-device, so sensitive calls stay off the internet. Close the tab and every temporary byte is gone.</p>
    </article>
    <article>
      <h3>Built for speed</h3>
      <p>The first run fetches codecs; afterwards, conversions are almost instant, even for hour-long recordings.</p>
    </article>
    <article>
      <h3>Smart compatibility</h3>
      <p>Automatic fallbacks ensure even browsers without native MP3 encoders load the LAME-based extension only when required.</p>
    </article>
    <article>
      <h3>Detailed telemetry</h3>
      <p>Real-time logs highlight what’s happening—file analysis, encoding stages, download readiness, and more.</p>
    </article>
  </section>

  <section class="faq" aria-label="Common questions">
    <div>
      <h3>Does it leave any trace?</h3>
      <p>No. Media is read into memory solely for the duration of the conversion and never sent to a server.</p>
    </div>
    <div>
      <h3>Why require a full download first?</h3>
      <p>Mediabunny needs the original bytes to inspect codecs and stream samples. Network downloads or embedded players won’t work—grab the actual file instead.</p>
    </div>
    <div>
      <h3>What about giant files?</h3>
      <p>Browser memory is the main limit. For multi-gigabyte source files, trim them first or use a desktop workflow.</p>
    </div>
  </section>

  <footer class="page-footer">
    <p>Need a fresh run? Drop another file above—Mediabunny keeps the encoder warm for your session.</p>
  </footer>
</main>
